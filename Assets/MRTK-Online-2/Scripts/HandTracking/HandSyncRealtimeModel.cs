using Normal.Realtime;
using Normal.Realtime.Serialization;

    [RealtimeModel]
    public partial class HandSyncRealtimeModel
    {
        [RealtimeProperty(1, true)]
        bool _isHandTrackingActive;
        
        [RealtimeProperty(2, false)]
        bool _isRightHandTrackingReliable;
        
        [RealtimeProperty(3, false)]
        bool _isLeftHandTrackingReliable;

        [RealtimeProperty(4, false)]
        float _rightGripIntensity;
        
        [RealtimeProperty(5, false)]
        float _leftGripIntensity;
    }


/* ----- Begin Normal Autogenerated Code ----- */
public partial class HandSyncRealtimeModel : RealtimeModel {
    public bool isRightHandTrackingReliable {
        get {
            return _isRightHandTrackingReliable;
        }
        set {
            if (_isRightHandTrackingReliable == value) return;
            _isRightHandTrackingReliableShouldWrite = true;
            _isRightHandTrackingReliable = value;
            InvalidateUnreliableLength();
        }
    }
    
    public bool isLeftHandTrackingReliable {
        get {
            return _isLeftHandTrackingReliable;
        }
        set {
            if (_isLeftHandTrackingReliable == value) return;
            _isLeftHandTrackingReliableShouldWrite = true;
            _isLeftHandTrackingReliable = value;
            InvalidateUnreliableLength();
        }
    }
    
    public float rightGripIntensity {
        get {
            return _rightGripIntensity;
        }
        set {
            if (_rightGripIntensity == value) return;
            _rightGripIntensityShouldWrite = true;
            _rightGripIntensity = value;
            InvalidateUnreliableLength();
        }
    }
    
    public float leftGripIntensity {
        get {
            return _leftGripIntensity;
        }
        set {
            if (_leftGripIntensity == value) return;
            _leftGripIntensityShouldWrite = true;
            _leftGripIntensity = value;
            InvalidateUnreliableLength();
        }
    }
    
    public bool isHandTrackingActive {
        get {
            return _cache.LookForValueInCache(_isHandTrackingActive, entry => entry.isHandTrackingActiveSet, entry => entry.isHandTrackingActive);
        }
        set {
            if (this.isHandTrackingActive == value) return;
            _cache.UpdateLocalCache(entry => { entry.isHandTrackingActiveSet = true; entry.isHandTrackingActive = value; return entry; });
            InvalidateReliableLength();
        }
    }
    
    private struct LocalCacheEntry {
        public bool isHandTrackingActiveSet;
        public bool isHandTrackingActive;
    }
    
    private LocalChangeCache<LocalCacheEntry> _cache = new LocalChangeCache<LocalCacheEntry>();
    
    private bool _isRightHandTrackingReliableShouldWrite;
    private bool _isLeftHandTrackingReliableShouldWrite;
    private bool _rightGripIntensityShouldWrite;
    private bool _leftGripIntensityShouldWrite;
    
    public enum PropertyID : uint {
        IsHandTrackingActive = 1,
        IsRightHandTrackingReliable = 2,
        IsLeftHandTrackingReliable = 3,
        RightGripIntensity = 4,
        LeftGripIntensity = 5,
    }
    
    public HandSyncRealtimeModel() : this(null) {
    }
    
    public HandSyncRealtimeModel(RealtimeModel parent) : base(null, parent) {
    }
    
    protected override void OnParentReplaced(RealtimeModel previousParent, RealtimeModel currentParent) {
        UnsubscribeClearCacheCallback();
    }
    
    protected override int WriteLength(StreamContext context) {
        int length = 0;
        if (context.fullModel) {
            FlattenCache();
            length += WriteStream.WriteVarint32Length((uint)PropertyID.IsRightHandTrackingReliable, _isRightHandTrackingReliable ? 1u : 0u);
            length += WriteStream.WriteVarint32Length((uint)PropertyID.IsLeftHandTrackingReliable, _isLeftHandTrackingReliable ? 1u : 0u);
            length += WriteStream.WriteFloatLength((uint)PropertyID.RightGripIntensity);
            length += WriteStream.WriteFloatLength((uint)PropertyID.LeftGripIntensity);
            length += WriteStream.WriteVarint32Length((uint)PropertyID.IsHandTrackingActive, _isHandTrackingActive ? 1u : 0u);
        } else if (context.unreliableChannel) {
            if (_isRightHandTrackingReliableShouldWrite) {
                length += WriteStream.WriteVarint32Length((uint)PropertyID.IsRightHandTrackingReliable, _isRightHandTrackingReliable ? 1u : 0u);
            }
            if (_isLeftHandTrackingReliableShouldWrite) {
                length += WriteStream.WriteVarint32Length((uint)PropertyID.IsLeftHandTrackingReliable, _isLeftHandTrackingReliable ? 1u : 0u);
            }
            if (_rightGripIntensityShouldWrite) {
                length += WriteStream.WriteFloatLength((uint)PropertyID.RightGripIntensity);
            }
            if (_leftGripIntensityShouldWrite) {
                length += WriteStream.WriteFloatLength((uint)PropertyID.LeftGripIntensity);
            }
        } else if (context.reliableChannel) {
            LocalCacheEntry entry = _cache.localCache;
            if (entry.isHandTrackingActiveSet) {
                length += WriteStream.WriteVarint32Length((uint)PropertyID.IsHandTrackingActive, entry.isHandTrackingActive ? 1u : 0u);
            }
        }
        return length;
    }
    
    protected override void Write(WriteStream stream, StreamContext context) {
        var didWriteProperties = false;
        
        if (context.fullModel) {
            stream.WriteVarint32((uint)PropertyID.IsRightHandTrackingReliable, _isRightHandTrackingReliable ? 1u : 0u);
            _isRightHandTrackingReliableShouldWrite = false;
            stream.WriteVarint32((uint)PropertyID.IsLeftHandTrackingReliable, _isLeftHandTrackingReliable ? 1u : 0u);
            _isLeftHandTrackingReliableShouldWrite = false;
            stream.WriteFloat((uint)PropertyID.RightGripIntensity, _rightGripIntensity);
            _rightGripIntensityShouldWrite = false;
            stream.WriteFloat((uint)PropertyID.LeftGripIntensity, _leftGripIntensity);
            _leftGripIntensityShouldWrite = false;
            stream.WriteVarint32((uint)PropertyID.IsHandTrackingActive, _isHandTrackingActive ? 1u : 0u);
        } else if (context.unreliableChannel) {
            if (_isRightHandTrackingReliableShouldWrite) {
                _isRightHandTrackingReliableShouldWrite = false;
                stream.WriteVarint32((uint)PropertyID.IsRightHandTrackingReliable, _isRightHandTrackingReliable ? 1u : 0u);
                didWriteProperties = true;
            }
            if (_isLeftHandTrackingReliableShouldWrite) {
                _isLeftHandTrackingReliableShouldWrite = false;
                stream.WriteVarint32((uint)PropertyID.IsLeftHandTrackingReliable, _isLeftHandTrackingReliable ? 1u : 0u);
                didWriteProperties = true;
            }
            if (_rightGripIntensityShouldWrite) {
                _rightGripIntensityShouldWrite = false;
                stream.WriteFloat((uint)PropertyID.RightGripIntensity, _rightGripIntensity);
                didWriteProperties = true;
            }
            if (_leftGripIntensityShouldWrite) {
                _leftGripIntensityShouldWrite = false;
                stream.WriteFloat((uint)PropertyID.LeftGripIntensity, _leftGripIntensity);
                didWriteProperties = true;
            }
            
            if (didWriteProperties) InvalidateUnreliableLength();
        } else if (context.reliableChannel) {
            LocalCacheEntry entry = _cache.localCache;
            if (entry.isHandTrackingActiveSet) {
                _cache.PushLocalCacheToInflight(context.updateID);
                ClearCacheOnStreamCallback(context);
            }
            if (entry.isHandTrackingActiveSet) {
                stream.WriteVarint32((uint)PropertyID.IsHandTrackingActive, entry.isHandTrackingActive ? 1u : 0u);
                didWriteProperties = true;
            }
            
            if (didWriteProperties) InvalidateReliableLength();
        }
    }
    
    protected override void Read(ReadStream stream, StreamContext context) {
        while (stream.ReadNextPropertyID(out uint propertyID)) {
            switch (propertyID) {
                case (uint)PropertyID.IsHandTrackingActive: {
                    _isHandTrackingActive = (stream.ReadVarint32() != 0);
                    break;
                }
                case (uint)PropertyID.IsRightHandTrackingReliable: {
                    _isRightHandTrackingReliable = (stream.ReadVarint32() != 0);
                    _isRightHandTrackingReliableShouldWrite = false;
                    break;
                }
                case (uint)PropertyID.IsLeftHandTrackingReliable: {
                    _isLeftHandTrackingReliable = (stream.ReadVarint32() != 0);
                    _isLeftHandTrackingReliableShouldWrite = false;
                    break;
                }
                case (uint)PropertyID.RightGripIntensity: {
                    _rightGripIntensity = stream.ReadFloat();
                    _rightGripIntensityShouldWrite = false;
                    break;
                }
                case (uint)PropertyID.LeftGripIntensity: {
                    _leftGripIntensity = stream.ReadFloat();
                    _leftGripIntensityShouldWrite = false;
                    break;
                }
                default: {
                    stream.SkipProperty();
                    break;
                }
            }
        }
    }
    
    #region Cache Operations
    
    private StreamEventDispatcher _streamEventDispatcher;
    
    private void FlattenCache() {
        _isHandTrackingActive = isHandTrackingActive;
        _cache.Clear();
    }
    
    private void ClearCache(uint updateID) {
        _cache.RemoveUpdateFromInflight(updateID);
    }
    
    private void ClearCacheOnStreamCallback(StreamContext context) {
        if (_streamEventDispatcher != context.dispatcher) {
            UnsubscribeClearCacheCallback(); // unsub from previous dispatcher
        }
        _streamEventDispatcher = context.dispatcher;
        _streamEventDispatcher.AddStreamCallback(context.updateID, ClearCache);
    }
    
    private void UnsubscribeClearCacheCallback() {
        if (_streamEventDispatcher != null) {
            _streamEventDispatcher.RemoveStreamCallback(ClearCache);
            _streamEventDispatcher = null;
        }
    }
    
    #endregion
}
/* ----- End Normal Autogenerated Code ----- */
